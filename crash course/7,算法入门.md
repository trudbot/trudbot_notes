# 算法

> 算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。

*同一个问题有不同的解决方案，可以由不同的算法来完成，算法也有优劣*

**算法的特征**
* 有穷性
  * （Finiteness）
  * 算法的有穷性是指算法必须能在执行有限个步骤之后终止；
* 确切性
  * (Definiteness)
  * 算法的每一步骤必须有确切的定义； 
* 输入项
  * (Input)
  * 一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；
* 输出项
  * (Output)
  * 一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；
* 可行性
  * (Effectiveness)
  * 算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）。
 #### 算法的评价标准为算法程序运行时所占用的时间和内存资源大小
**算法的时间复杂度**
* **定义n为问题的规模**
* 时间频度：一个算法中**语句的执行次数。**
  * 一个算法的具体运行时间需要上机测试才能得到，但我们评价算法并不需要定量，只需要定性。
  * 一个算法的运行时间和算法中语句的执行次数成正相关。一般，算法中语句执行次数越大，运行时间也越长。
  * 时间频度记为T(n).
* 时间复杂度
  * 用O(f(n))表示
  * 时间复杂度用以描述T(n)随问题规模n变化的规律
  * > 时间复杂度是衡量一个**量级**上的差距，这个量级上的差距表现在当n突破到一个点的时候，时间复杂度低的算法就一定要比时间复杂度高的算法快，而且n越大，这个优势越明显。
  * 也就是说时间复杂度用来比较T(n)的数量级，不同时间复杂度的算法在问题规模变大时T(n)也会相差越大。
  * 举例：
    * 若T(n)=3n+1，则时间复杂度为O(n) 
    * 若T(n)=n^2 +n,则时间复杂度为O(n^2^)
    * 若T(n)=5,则时间复杂度为O(1)
  * 可以发现时间复杂度即为 忽略系数的T(n)最高阶项
  * O(1)<O(logn)<O(n)<O(nlogn)<O(n^2^)<O(n^3^)<O(2^n^)<O(n!)<O(n^n^)
  * 时间复杂度可以近似代表原来函数的总体趋势
  * python实例：
```python
实例一
print('a')
print('b')
print('c')
# 显然上述代码T(n)=3,时间复杂度为O(1)  
```
```
# 实例二  
for i in range(n):  
    print(i)
# 易知，当问题规模n增大时，T(n)随n线性增大
# 所以时间复杂度为O(n)
```
```
# 实例三
for a in range(n):
    for b in range(n):
        print(1)
# 显然T(n)=2*n^2+n,时间复杂度为O(n^2) 
```
*由上述时间复杂度O(n)的变化可以得出这样的结论：O(n)中n的几次方取决于自定义函数或算法中存在几个循环。*

```
实例四.
i = 1
while i < n:
    i = i*2

># 当计算时间复杂度时，我们只需要分析最内层的代码

># 在本例中即为（i=i*2)

>#显然此条语句的执行次数跟问题规模n成以二为底的对数关系

># 所以空间复杂度为O(logn)
```

**算法的空间复杂度**
> 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。

一个算法在计算机存储器上所占用的存储空间，包括**程序代码所占用的空间**，**输入数据所占用的空间**和**辅助变量所占用的空间这三个方面**。
