#### 原码

用原码表示一个数时，其最高位作为符号位，1表示负，0表示正， 其余位是二进制数的绝对值。

如十进制数-13， 其原码为10001101(本文二进制数统一采用八位)

#### 反码

正数的反码等同于其原码，负数的原码是其原码除符号位外取反的结果。

如(-13)[十进制] == (10001101)[原码] == (11110010)[反码]

#### 补码

正数的补码等同于其原码，负数的反码是再其反码的的基础上加一的结果

如(-13)[十] == (11110011)[补]

*要注意的是，无论是原码转补码还是补码转原码，转换规则都是除符号位取反后在加1*

### 为什么会有这些，为什么要有这些

原码、反码和补码的出现都是为了解决计算机对整数的编码问题。

原码无疑是最便于人类理解和计算的编码方式，但是对于计算机,原码有加减乘除四种运算方式，更要考虑符号位而实行不同的计算策略，显然会让cpu的设计无比复杂。 

人们想到了用加法来代替其他的三种运算方式

如1-1可以用1+(-1)来表示， 这就要求符号位也要参与运算

**对于原码**：
1-1 = (00000001)[原]+(10000001)[原] = (10000010)[原] = -2
—— 原码为人类而设计，计算机无法正确处理原码符号位。

**于是反码出现了**
首先了解一下反码的特殊运算规则
* 进行加法运算时，反码的符号位可以与低位的进位进行相加
* **若符号位产生进位，则该进位加到最低位(循环进位)**，这样保证了最高位始终是符号位

于是有
3-1 = (00000011)[反]+(11111110)[反] = (00000010)[反] = 2
1-1 = (00000001)[反]+(11111110)[反] = (11111111)[反] = -0
-2-1 = (11111101)[反]+(11111110)[反] = (11111100)[反] = -3

可以看到，反码基本解决了减法问题
但反码的一个缺陷就是0有两种编码方式00000000或10000000，即0的符号问题，这可以体现在用补码计算1-1，结果为-0.

**于是补码出现了**

1-1 = (00000001)[补]+(11111111)[补] = 00000000[补] = 0
先说结论，这条算式是正确的
但我们动手去计算的时候，会发现在计算符号位的时候是有一个进位的，但在结果中并没有体现出来。
原因是该算式结果并没有溢出，所以这个进位没有意义，便舍去了。[深入了解](https://blog.csdn.net/u011240016/article/details/52567295)

补码较好的修正了反码的一些问题，现代计算机中整数都是用补码的形式存储的。


