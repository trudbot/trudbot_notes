# 指针

*什么是地址*

内存中每个用于数据存取的基本单位，都被赋予一个唯一的序号，称为地址，也叫做内存地址。
内存地址指系统 RAM 中的特定位置，通常以十六进制的数字表示。

*什么是指针*
指针也就是内存地址，指针变量是用来存放内存地址的变量
指针虽然本质上是个非负整数，但其不能被用来进行运算以及其它操作

**指针变量的声明与赋值**

声明：``` type *name;```

* 指针变量用于存放某个变量的内存地址
* type为存放地址时的数据类型限制，如为int，则该指针变量就只能存储int变量的地址
* ‘*’为取值符，```*指针变量```表示该指针变量存放的地址对应的数据
* 也将指针变量的类型成为‘type *’

赋值：
```
int *i;
int j;
i = &j;
```
或
```
int j;
int *i = &j;
```
给指针变量赋值时，要用取地址符&加对应类型的变量
如上，i中存放着j的地址，也称i指向j
<P>*i与j是等价的，因为i指向j，
j的值变化时，*i也随之变化</p>
如

```
int *i;
int a;
i = &a;
a = 4;
printf("%d\n", *i == a); //1
a = 9;
printf("%d", *i); //9
```

指针应用举例：交换值函数
```
# include <stdio.h>

void exchange(int *i, int *j)
{
    int temp;
    temp = *i;
    *i = *j;
    *j = temp;
}

int main(void)
{
    int a = 3;
    int b = 5;
    exchange(&a, &b);
    printf("a = %d, b = %d", a, b);//a = 5, b = 3
    return 0;
}
```
这里利用了指针的指向性，实现了在被调函数中修改主函数的变量(即无视变量作用域对变量进行操作）。

**空指针**

当新声明的指针暂时没有合适的指向时，可以将NULL传给它，以让程序更安全。
```
int *p = NULL;
```
NULL其实也是内存地址编号，指向编号为0的内存单元，计算机中规定这块内存单元不可读、不可写。



**指针与数组**

*指针与一维数组*

一维数组名是一个指针常量， 存放着数组第一个元素的地址（首地址）

```
int arr[3] = {1, 2, 3};
int * i;
i = arr;
printf("%d", *i);  // 1
return 0;
```
因为数组各元素的内存地址是连续的，所以通过首地址加若干个地址增量若就可以得到每一个元素的地址
如
```
int arr[] = {1, 2, 3, 4 , 5};
printf("%d", *(arr+1));//2
```
即arr[i] = *(arr+i)

而对于一个指针变量i, 有<b>  i[j] == *(i+j)</b>

**数组指针**
即数组的指针

声明：``` type (*name)[size];```
<p>用括号将*name括起的原因是name[size]的优先级比*name的优先级高, 用优先级更高的括号表明这是一个指针</p>

赋值：
```
int arr[5] = {1, 2, 3, 4, 5};
int (*p)[5];
p = &arr;
```
注意：
* 数组指针的长度要与数组长度相同
* arr 和 &arr 的区别
  * arr与&arr的值相同，但含义不同
  * arr是数组第一个元素的地址
  * arr是数组的整个数组的地址
```
int arr[] = {1, 2, 3, 4};

printf("%X, %X\n", arr, &arr); //61FE10, 61FE10


printf("%X, %X", arr+1, &arr+1); //61FE14, 61FE20

//可以发现，arr+1让地址增大了4个字节，也就是数组下一个元素的地址
//而&arr+1让地址增加了16个字节，也就是跳过了整个数组
//所以arr是元素级别的，而&arr是数组级别的
```
既然数组指针p中存放了数组地址，所以**p指向的是整个数组**, *p完全等价于数组
如：
```
int arr[] = {2, 3, 4, 5, 6};
int(*p)[] = &arr;
printf("%d", (*p)[1]); // 3
```

**指针数组**
即元素为指针的数组

声明：type * name[size];
```
int i, j , k;
i = j = k = 1;
int * arr[] = {&i, &j, &k};
int a;
for (a=0; a<3; a++)
{
    printf("%d ", *arr[a]); ///1 1 1
}
```

**指针的算术运算**

如上，指针可以与整型进行加减运算，指针会移动对应的单元数，以此可以实现对数组的访问。

但指针和指针之间一般不能进行算术运算

当两个指针指向同一连续的内存空间的不同存储单元时，两个指针可以相减，指针减指针表示两个指针间隔的单元格数

```
int arr[] = {1, 2, 3, 4, 5};
int *i, *j;
i = arr;
j = &arr[4];
printf("%d", j - i);// 4
//下标之差
```

**关于内存地址（指针）的一些知识**

内存地址只是一个编号，代表着一块内存空间，大小为1byte
也就是一个内存地址代表着1byte的空间

内存地址用四位16进制或8位16进制存储，无论存储的是哪种类型变量的地址，指针变量被分配的内存空间是相同的
```
printf("%d %d %d", sizeof(int*), sizeof(char*), sizeof(float*));
/// 8 8 8
```
为什么呢？
原因是指针变量中只存放了对应变量的首地址， 如一个标准整型占四个字节， 它的指针变量只存放了它第一个字节的地址。

既然指针变量只保存了首地址，那么为什么它却能指向整个变量呢？
关键在于对指针变量的类型声明，因为变量被分配的内存空间是连续的一块，所以只需要首地址+长度就能准确定位这一块内存空间。对指针变量的类型声明就是提供将要被指向的变量的内存长度。

**多级指针**
指针变量也是变量，也有内存地址，所以理论上指针变量的地址也能存放到某个变量中。

存放type类型变量地址的指针变量叫一级指针，类型为type*
存放一级指针的内存地址的变量叫二级指针，类型为type**
以此类推

```
int i = 100;
int *j = &i;
int **k = &j;
printf("%d %d %d", i, *j, **k);//100 100 100
```
**函数的指针**

> 一个函数的执行过程：
在编译时，系统为函数代码块分配一块存储空间，生成一个指向函数的指针变量，这个指针变量指向函数的入口地址，依次自上而下指向每一条代码指令并执行指令。而这段存储空间的起始地址(又称入口地址)便称为这个函数的指针。

声明语法：type (*name)(type of args);

如：int (*p)(int, int);

函数指针的形式要与被赋值的函数相符

如：

```
# include <stdio.h>

int sum(int a, int b)
{
    return a+b;
}

int main(void)
{
    int (*p)(int, int);
    p = sum;
    printf("%d", (*p)(2, 3));//5
    //*p与sum函数完全等价
    return 0;
}
```
**指针的优点**

> （1）可以提高程序的编译效率和执行速度，使程序更加简洁。
（2）通过指针被调用函数可以向调用函数处返回除正常的返回值之外的其他数据，从而实现两者间的双向通信。
（3）利用指针可以实现动态内存分配。
（4）指针还用于表示和实现各种复杂的数据结构，从而为编写出更加高质量的程序奠定基础。
（5）利用指针可以直接操纵内存地址，从而可以完成和汇编语言类似的工作
（6）跟容易实现函数的编写和调用。
