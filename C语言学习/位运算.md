## 位运算

位运算就是对二进制数的每一位进行操作，位运算可以分为位逻辑运算和和移位运算。

通过位运算符对位进行操作
| 位运算符 | 解释 |
| :---: | :---: |
| & | 按位与 |
| \| | 按位或 |
| ^ | 按位异或 |
| ~ | 按位取反 |
|  << | 左移 |
|>>| 右移  |

注意，这些运算符只能用于整型操作数。
#### 位逻辑运算

以下示例中的四位二进制数仅是真值部分，不包括符号位。

**按位与**

按位与就是对两个数的补码的对应的每一位进行与运算。
如  
```
2&5
2 -- 0010
  &
5 -- 0101
----------
     0000 -- 0

5&7   
5 -- 0101
  &
7 -- 0111
----------
     0101 -- 5
```
代码
```
int i = 7&5;
printf("%d", i); // 5
```
**按位或 和 按位取反**
```
int i = 3|5;
int j = ~3;
printf("i = %d, j = %d", i, j);//i = 7, j = -4

/*
3|5
3 -- 0011
  |
5 -- 0101
----------
     0111 -- 7

~3   值得注意的是符号位也会被取反
3 -- 0011
  ~
----------
     1100
补码转换成原码即除符号位取反再加一
取反：0011
加一：0100
符号位取反：正数变负数
所以结果为-4
*/
```
**按位异或**
先复习一下异或运算：
当两个值不相同，返回1
当两个值相同，返回0
```
printf("%d",  3^5); // 6

/*
3^5, 符号位相同，结果为正

3 -- 0011
  ^
5 -- 0101
----------
     0110 -- 6

*/
```
**位逻辑运算的应用**

*判断数的奇偶性*
一个二进制数的奇偶性取决于它的第一位,第一位为1则为奇数,第一位为0则为偶数。（虽然负数的补码进行的取反，但也加了1，因此第一位仍然能判断奇偶性）

因此对于一个整数i,有
若 i&1 = 1, i为奇数
若 i&1 = 0, i为偶数

解释:i与1进行按位与运算，而1除了第一位其他位都为0， 所以i&1的结果只取决于i的第一位，第一位为1结果为，第一位为0结果为0。

*取操作数的某一位或某几位*
由上例可推广，让某一位为1、其它位都为0的一个数与整数i进行按位与运算，就可以得到 i 的对应位的情况，而屏蔽无关位。

位运算还有无数的妙用。

#### 移位运算

**按位左移**

```
char i = 4;
printf("%d\n", i<<1);//8
printf("%d\n", i<<2);//16
printf("%d\n", i<<3);//32
```
按位左移就是将一个数的补码左移，溢出的高位舍去，空缺的低位补0.
如4--0100,左移后是1000.

在结果不溢出的情况下，一个整数左移n位相当于乘以 2^n^.
当然也有溢出的情况, 
如8位二进制数127, 补码为01111111
当左移一位时,结果为11111110, 符号位变为1,转换为原码:10000010, 等于-2.

也就是说如果一个数的2^n^倍没有超出范围, 那么左移n位的结果就是这个数乘以2^n^

**按位右移**

```
int i = 7;
printf("%d\n", i>>1);//3
printf("%d", -i>>1);//-4
```
右移和左移略有不同的是, 右移时对高位空缺处的填充由符号位的值决定.即正数补0, 负数补1.

如7 -- 0111, 右移一位, 0011,结果为3

一般的,一个数i进行右移n的时侯, 结果为 i/2^n^
当n对于操作数过大时,数据可能完全丢失.

**移位运算的应用**

当我们要让一个值不大的整型变量自乘2
可以: i *= 2;
也可以: i = i<<1;
因为位运算是直接对原数据进行操作的, 而乘法要把数据取出,再进行一系列操作,最后放回.  所以位运算要比算术运算更快.


