顾名思义， 并查集是一种在集合的合并和查找操作上有优越性能的数据结构

并查集是集合的集合， 在并查集中， 每个集合被抽象为一颗树， 并查集为一个森林； 并查集中每个结点保存的信息是它的父节点的编号， 而根结点则保存自己的编号， 所以整个集合的编号就是根结点的编号

用一个数组p[N]来保存所有元素的父结点编号
**并查集的操作**

判断树根
```
if(p[x] == x)
```

求某一个元素所在集合的编号
```
while(p[x] != x) x = p[x];
```

合并两个集合, x y 是两个集合的编号
```
p[x] = y;
```
---

显然, 查找编号的操作跟树的高度成正比, 以此可以对其进行优化

**路径压缩**
我们在每次查找编号时， 如果当前结点不是根结点， 我们就把根结点编号赋予当前结点的前驱， 即把当前结点直接移动到成为根结点的儿子

由此我们可以写出核心的查找函数
```
int find(int x)
{
    if(x == p[x]) return x;
    else return p[x] = find(p[x]);
}
```
**集合大小**

在维护并查集的时候我们可以另起一个数组来保存每个集合的大小
```
int w[N]
```
初始时每个点单独在一个集合, 所以对于任意i, w[i] = 1

我们在构建并查集时只用根结点所在位置保存集合大小, 即只维护根结点位置w为集合大小

在每次合并集合时
```
p[x] = y;//把x集合合并到y下
w[y] += w[x]; //y集合大小改变
```


